/* Main.c file generated by New Project wizard
 *
 * Created:   Fri May 14 2021
 * Processor: MSP430G2553
 * Compiler:  GCC for MSP430
 */

#include <MSP430.h>
#include <inttypes.h>

#define CMD 0
#define DATA 1

#define LCD_OUT P2OUT
#define LCD_DIR P2DIR	
#define D4 BIT4
#define D5 BIT5
#define D6 BIT6
#define D7 BIT7
#define RS BIT2
#define EN BIT3

#define SW BIT3
#define LED BIT1

#define AIN BIT0

void delay(uint16_t t)
{
   uint8_t i;
   for(i=t; i>0; i--)
      __delay_cycles(100);
}

void pulseEN(void)
{
   LCD_OUT |= EN;
   delay(1);
   LCD_OUT &= ~EN;
   delay(1);
}

void lcd_write(uint8_t value, uint8_t mode)
{
   if(mode == CMD)
      LCD_OUT &= ~RS;			//Set RS low for command mode
   else
      LCD_OUT |= RS;			//Set RS high for data mode
   
   LCD_OUT = ((LCD_OUT & 0x0F) | (value & 0xF0));
   pulseEN();
   delay(1);
   
   LCD_OUT = ((LCD_OUT & 0x0F) | ((value << 4) & 0xF0));
   pulseEN();
   delay(1); 
}

void lcd_print(char *s)
{
   while(*s)
   {
      lcd_write(*s,DATA);
      s++;
   }
}

void lcd_setCursor(uint8_t row, uint8_t col)
{
   const uint8_t row_offsets[] = { 0x00, 0x40};
   lcd_write(0x80 | (col + row_offsets[row]), CMD);
   delay(1);
}

void lcd_printNumber(unsigned int num)
{
   char buf[3];				//creating an array of size 3
   char *str = &buf[2];			//initializing pointer to the end of the array
   
   *str = '\0';				//storing null pointer at the end of the string
   
   do
   {
      unsigned long m = num;		//storing number in the variable m
      num /= 10;			//dividing number by 10
      char c = (m - 10*num) + '0';	//finding least place value and adding it to get charecter value of digit
      *--str = c;			//decrementing charecter and storing it 
   }while(num);
   
   lcd_print(str);
}      

void lcd_init()	
{
   LCD_DIR |= (D4+D5+D6+D7+RS+EN);
   LCD_OUT &= ~(D4+D5+D6+D7+RS+EN);

   delay(150);				//Pwoer up 15ms wait;
   lcd_write(0x33, CMD);		//Initialization sequence 1
   delay(50);				//Pwoer up 4.1ms wait;
   lcd_write(0x32, CMD);		//Initialization sequence 2
   delay(1);
   
   lcd_write(0x28, CMD);		//4 bit mode 2 line
   delay(1);
   
   lcd_write(0x0C, CMD);		//Display on, cursor off, bink off
   delay(1);   
   
   lcd_write(0x01, CMD);		//clear screen
   delay(20);
   
   lcd_write(0x06, CMD);		//4 bit mode 2 line
   delay(1);
   
   lcd_setCursor(0,0);			//Goto row 1 coloumn 1
}

void register_settings_for_ADC10()
{
   ADC10AE0 |= AIN;			//P1.0 ADC option select
   ADC10CTL1 = INCH_0;			//ADC channel 1 P1.0
   ADC10CTL0 = SREF_0 + ADC10SHT_3 + ADC10ON; //Ref = Vdd, 64 clk sample and hold
}

void register_settings_for_UART()
{
   P1SEL = BIT1 + BIT2;			//Select Tx Rx for communicating on P1.1 and P1.3
   P1SEL2 = BIT1 + BIT2;		
   
   UCA0CTL1 |= UCSSEL_1;		//UART clk ACLK
   UCA0BR0 = 3;				//Baud rate settings for 32Khz 9600
   UCA0BR1 = 0;				//Baud rate settings for 32Khz 9600
   UCA0MCTL = UCBRF_0 + UCBRS_3;	//Modulation settings for 32Khz 9600
   UCA0CTL1 &= ~UCSWRST;		//Initialize UART module
   IE2 |= UCA0RXIE;			//Enable Rx interrupt
}

void Calc_Current(int ADC)
{
   float val = ADC/1023;
   int int_part = val*33000;
   int decimal_part = (val - (float)int_part)*100;
   
   lcd_write(0x01, CMD);
   delay(20);
   lcd_setCursor(0,0);
   lcd_print("Current is");
   lcd_setCursor(1,0);
   lcd_printNumber(int_part);
   lcd_print(".");
   lcd_printNumber(decimal_part);
   lcd_print(" uA");
   delay(6000);
}
   
void Calc_Voltage(int ADC)
{
   float val = (ADC/1023) * 26.4;
   int int_part = val;
   int decimal_part = (val - (float)int_part)*100;
   
   lcd_write(0x01, CMD);
   delay(20);
   lcd_setCursor(0,0);
   lcd_print("Voltage is");
   lcd_setCursor(1,0);
   lcd_printNumber(int_part);
   lcd_print(".");
   lcd_printNumber(decimal_part);
   lcd_print(" V");
   delay(6000);
}

uint8_t state = 0;

int main (void)
 { 
   // Write your code here
    WDTCTL = WDTPW + WDTHOLD;		//Switching off watchdog timer
    
    //uint8_t count = 0;
    
    P2DIR |= SW;
    
    P3DIR |= LED;
    P3OUT |= LED;
    
    register_settings_for_UART();
    
    //__bis_SR_register(LPM0_bits + GIE); 	//Ebabling timer interrupt
    
    lcd_init();				//initializing LCD
    
    register_settings_for_ADC10();
            
    while (1)
    {
        ADC10CTL0 |= ENC + ADC10SC; 	//Sampling and conversion start
       
	while(ADC10CTL1 & ADC10BUSY);	//waiting for conversion to end
	   
	if(state == 1)
	{
	   P1OUT |= SW;
	   Calc_Current(ADC10MEM);
	}
	else
	{
	   P1OUT &= ~SW;
	   Calc_Voltage(ADC10MEM);
	}
    }
     
 }  
   
 
#pragma vector = USCIAB0RX_VECTOR	//UART RX Interrupt vector
 __interrupt void USCI0RX_ISR(void)
 {
    state = ~state;
 }